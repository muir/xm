package xoptrace

import (
	"bytes"
	"crypto/rand"
	"database/sql"
	"database/sql/driver"
	"encoding"
	"encoding/hex"

	"github.com/pkg/errors"
)

// MACRO HexBytes
// ZZZ is both a binary and text representation of a fixed-length
// byte slice.  It is comparable and relatively low-overhead.  It
// serializes as hex digits.
type ZZZ struct {
	b [zzz]byte
	h [zzz * 2]byte
}

// MACRO HexBytes
type WrappedZZZ struct {
	*ZZZ
	offset int
	trace  *Trace
}

// MACRO HexBytes
var _ driver.Valuer = ZZZ{}
var _ sql.Scanner = &ZZZ{}
var _ encoding.TextMarshaler = ZZZ{}
var _ encoding.TextUnmarshaler = &ZZZ{}

// MACRO HexBytes
var zeroHexZZZ = bytes.Repeat([]byte{'0'}, zzz*2)

// MACRO HexBytes
func newZZZ() ZZZ {
	var x ZZZ
	copy(x.h[:], zeroHexZZZ)
	return x
}

// MACRO HexBytes
func NewZZZFromSlice(b []byte) ZZZ {
	var x ZZZ
	setBytes(x.b[:], b)
	hex.Encode(x.h[:], x.b[:])
	return x
}

// MACRO HexBytes
var zeroZZZb = [zzz]byte{}

// MACRO HexBytes
func (x ZZZ) IsZero() bool     { return x.b == zeroZZZb }
func (x ZZZ) Bytes() []byte    { return x.b[:] }
func (x ZZZ) HexBytes() []byte { return x.h[:] }
func (x ZZZ) String() string   { return string(x.h[:]) }

// MACRO HexBytes
func (x WrappedZZZ) String() string {
	return x.trace.headerString[x.offset : x.offset+zzz*2]
}

// MACRO HexBytes
func (x WrappedZZZ) SetBytes(b []byte) {
	setBytes(x.b[:], b)
	hex.Encode(x.h[:], x.b[:])
	x.trace.rebuild()
}

// MACRO HexBytes
func (x WrappedZZZ) Set(b [zzz]byte) {
	x.b = b
	hex.Encode(x.h[:], x.b[:])
	x.trace.rebuild()
}

// MACRO HexBytes
func (x *ZZZ) Array() [zzz]byte {
	return x.b
}

// MACRO HexBytes
func (x WrappedZZZ) SetString(s string) {
	setBytesFromString(x.b[:], s)
	hex.Encode(x.h[:], x.b[:])
	x.trace.rebuild()
}

// MACRO HexBytes
func (x WrappedZZZ) SetZero() {
	x.b = [zzz]byte{}
	hex.Encode(x.h[:], x.b[:])
	x.trace.rebuild()
}

// MACRO HexBytes
func (x WrappedZZZ) SetRandom() {
	x.ZZZ.setRandom()
	x.trace.rebuild()
}

// MACRO HexBytes
func (x *ZZZ) setRandom() {
	for {
		_, _ = rand.Read(x.b[:])
		if x.b != zeroZZZb {
			break
		}
	}
	hex.Encode(x.h[:], x.b[:])
}

// MACRO HexBytes
func (x *ZZZ) initialize() {
	hex.Encode(x.h[:], x.b[:])
}

// MACRO HexBytes
func (x ZZZ) initialized(t Trace) ZZZ {
	if !t.initialized {
		hex.Encode(x.h[:], x.b[:])
	}
	return x
}

// MACRO HexBytes
func (x *ZZZ) Scan(src any) error {
	switch t := src.(type) {
	case []byte:
		*x = NewZZZFromSlice(t)
		return nil
	case string:
		setBytesFromString(x.b[:], t)
		hex.Encode(x.h[:], x.b[:])
		return nil
	default:
		return errors.Errorf("unexpected type %T in ZZZ scan", src)
	}
}

// MACRO HexBytes
func (x ZZZ) Value() (driver.Value, error) {
	return x.Bytes(), nil
}

// MACRO HexBytes
func (x ZZZ) MarshalText() ([]byte, error) {
	return x.h[:], nil
}

// MACRO HexBytes
func (x *ZZZ) UnmarshalText(h []byte) error {
	if len(h) != zzz*2 {
		return errors.Errorf("UnmarshalText ZZZ: input is the wrong (%d) length", len(h))
	}
	_, err := hex.Decode(x.b[:], h)
	if err != nil {
		return errors.Wrap(err, "UnmarshalText ZZZ")
	}
	// We re-encode to because h might use different case for the letters
	// that what we use elsewhere
	hex.Encode(x.h[:], x.b[:])
	return nil
}
