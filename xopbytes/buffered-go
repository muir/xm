package xopbytes

// Buffered batches up calls to another BytesWriter.  The buffer is "flushed"
// when there is a Flush from the level above.  It is also flushed when a 
// sufficient quantity of data has been buffered on a per-request basis.
// Calls to DefineAttribute and DefineEnum are passed through without buffering.
func Buffered(w BytesWriter, size int) BytesWriter {
	return &buffered{
		w: w,
		size: size,
	}

	DefineAttribute(*xopat.Attribute)            // duplicate calls should be ignored
	DefineEnum(*xopat.EnumAttribute, xopat.Enum) // duplicate calls should be ignored

func (b &buffered) Buffered() bool { return true }

func (b &buffered) Span(
	request.completedBuilders <- rq

	XXX send starts?   Probably no if buffered
	Span(trace.HexBytes8, Builder) error    
	Line(trace.HexBytes8, xopnum.Level, time.Time, Builder) error
	AttributeReferenced(*xopat.Attribute) error

func (r *request) Flush() {
	XXX
	if r.logger.perRequestBufferLimit != 0 {
		var wg sync.WaitGroup
		wg.Add(1)
		r.flushRequest <- &wg
		wg.Wait()
func (r *request) maintainBuffer() {
	r.flushRequest = make(chan *sync.WaitGroup)
	r.finalized = make(chan struct{})
	r.completedLines = make(chan *line, lineChanDepth)
	r.completedBuilders = make(chan *builder, lineChanDepth)
	r.writeBuffer = make([]byte, 0, r.logger.perRequestBufferLimit/16)
	handleBuilder := func(builder *builder) {
		if len(builder.B)+len(r.writeBuffer) > r.logger.perRequestBufferLimit {
			r.flushBuffer()
		}
		if len(builder.B) > r.logger.perRequestBufferLimit {
			// TODO: split into multiple writes
		}
		r.writeBuffer = append(r.writeBuffer, builder.B...)
		builder.reclaimMemory()
	}
	handleLine := func(line *line) {
		if len(line.B)+len(r.writeBuffer) > r.logger.perRequestBufferLimit {
			r.flushBuffer()
		}
		if len(line.B) > r.logger.perRequestBufferLimit {
			// TODO: split into multiple writes
		}
		r.writeBuffer = append(r.writeBuffer, line.B...)
		line.reclaimMemory()
	}
	handleFlush := func(wg *sync.WaitGroup) {
		defer wg.Done()
		// drains lines & builders before flush!
	Flush:
		for {
			select {
			case builder := <-r.completedBuilders:
				handleBuilder(builder)
			case line := <-r.completedLines:
				handleLine(line)
			default:
				break Flush
			}
		}
		r.flushBuffer()
	}
	handleClose := func() {
		// drain everything else first
	Request:
		for {
			select {
			case builder := <-r.completedBuilders:
				handleBuilder(builder)
			case line := <-r.completedLines:
				handleLine(line)
			case wg := <-r.flushRequest:
				handleFlush(wg)
			default:
				break Request
			}
		}
		r.flushBuffer()
	}
	r.logger.activeRequests.Add(1)
	go func() {
		defer r.logger.activeRequests.Done()
		for {
			select {
			case builder := <-r.completedBuilders:
				handleBuilder(builder)
			case line := <-r.completedLines:
				handleLine(line)
			case wg := <-r.flushRequest:
				handleFlush(wg)
			case <-r.finalized:
				handleClose()
				return
			}
		}
	}()
}

func (r *request) flushBuffer() {
	if len(r.writeBuffer) == 0 {
		return
	}
	_, err := r.writer.Write(r.writeBuffer) XXX
	if err != nil {
		r.errorFunc(err)
	}
	r.writer.Flush() XXX
	r.writeBuffer = r.writeBuffer[:0]
}

