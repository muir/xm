package trace

import (
	"bytes"
	"crypto/rand"
	"encoding/hex"
)

// MACRO HexBytes
type ZZZ struct {
	b [zzz]byte
	h [zzz * 2]byte
}

// MACRO HexBytes
var zeroHexZZZ = bytes.Repeat([]byte{'0'}, zzz*2)

// MACRO HexBytes
func NewZZZ() ZZZ {
	var x ZZZ
	copy(x.h[:], zeroHexZZZ)
	return x
}

// MACRO HexBytes
var zeroZZZb = [zzz]byte{}

// MACRO HexBytes
func (x ZZZ) IsZero() bool     { return x.b == zeroZZZb }
func (x ZZZ) String() string   { return string(x.h[:]) }
func (x ZZZ) Bytes() []byte    { return x.b[:] }
func (x ZZZ) HexBytes() []byte { return x.h[:] }

// MACRO HexBytes
func (x *ZZZ) SetBytes(b []byte) {
	setBytes(x.b[:], b)
	hex.Encode(x.h[:], x.b[:])
}

// MACRO HexBytes
func (x *ZZZ) Set(b [zzz]byte) {
	x.b = b
	hex.Encode(x.h[:], x.b[:])
}

// MACRO HexBytes
func (x *ZZZ) SetString(s string) {
	setBytesFromString(x.b[:], s)
	hex.Encode(x.h[:], x.b[:])
}

// MACRO HexBytes
func (x *ZZZ) SetZero() {
	x.b = [zzz]byte{}
	hex.Encode(x.h[:], x.b[:])
}

// MACRO HexBytes
func (x *ZZZ) SetRandom() {
	for {
		_, _ = rand.Read(x.b[:])
		if !allZero(x.b[:]) {
			break
		}
	}
	hex.Encode(x.h[:], x.b[:])
}

// MACRO HexBytes
func (x ZZZ) Copy() ZZZ {
	return x
}
