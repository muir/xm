package xoppb

import (
	"context"
	"encoding/json"
	"reflect"
	"runtime"
	"strings"
	"sync/atomic"
	"time"

	"github.com/xoplog/xop-go/xopat"
	"github.com/xoplog/xop-go/xopbase"
	"github.com/xoplog/xop-go/xopbytes"
	"github.com/xoplog/xop-go/xopnum"
	"github.com/xoplog/xop-go/xoptrace"
	"github.com/xoplog/xop-go/xoputil"

	"github.com/google/uuid"
)

var _ xopbase.Logger = &Logger{}
var _ xopbase.Request = &request{}
var _ xopbase.Span = &span{}
var _ xopbase.Line = &line{}
var _ xopbase.Prefilling = &prefilling{}
var _ xopbase.Prefilled = &prefilled{}
var _ xopbytes.Buffer = &builder{}
var _ xopbytes.Line = &line{}
var _ xopbytes.Span = &span{}
var _ xopbytes.Request = &request{}

func New(w xopbytes.BytesWriter, opts ...Option) *Logger {
	log := &Logger{
		writer:        w,
		id:            uuid.New(),
		timeFormatter: defaultTimeFormatter,
	}
	prealloc := xoputil.NewPrealloc(log.preallocatedKeys[:])
	for _, f := range opts {
		f(log, prealloc)
	}
	if log.tagOption == 0 {
		if w.Buffered() {
			log.tagOption = SpanIDTagOption
		} else {
			log.tagOption = SpanIDTagOption | TraceIDTagOption
		}
	}
	log.activeRequests.Add(1)
	return log
}

func (logger *Logger) ID() string           { return logger.id.String() }
func (logger *Logger) Buffered() bool       { return logger.writer.Buffered() }
func (logger *Logger) ReferencesKept() bool { return false }

func (logger *Logger) Request(_ context.Context, ts time.Time, bundle xoptrace.Bundle, name string) xopbase.Request {
	request := &request{
		span: span{
			logger:    logger,
			bundle:    bundle,
			name:      name,
			startTime: ts,
			endTime:   ts.UnixNano(),
			isRequest: true,
		},
	}
	if logger.tagOption&TraceNumberTagOption != 0 {
		request.idNum = atomic.AddInt64(&logger.requestCount, 1)
	}
	request.request = request
	request.writer = logger.writer.Request(request)

	return request
}

func (r *request) Flush() {
	r.writer.Flush()
}

func (r *request) Final() {
	r.writer.ReclaimMemory()
}

func (r *request) SetErrorReporter(reporter func(error)) { r.errorFunc = reporter }
func (r *request) GetErrorCount() int32                  { return atomic.LoadInt32(&r.errorCount) }
func (r *request) GetAlertCount() int32                  { return atomic.LoadInt32(&r.alertCount) }

func (s *span) Span(_ context.Context, ts time.Time, bundle xoptrace.Bundle, name string, spanSequenceCode string) xopbase.Span {
	n := &span{
		logger:       s.logger,
		writer:       s.writer,
		bundle:       bundle,
		name:         name,
		request:      s.request,
		startTime:    ts,
		endTime:      ts.UnixNano(),
		sequenceCode: spanSequenceCode,
	}
	return n
}

func (s *span) Done(t time.Time, _ bool) {
	atomic.StoreInt64(&s.endTime, t.UnixNano())
	s.flushAttributes()
}

func (s *span) Boring(bool)                {}
func (s *span) ID() string                 { return s.logger.id.String() }
func (s *span) GetBundle() xoptrace.Bundle { return s.bundle }
func (s *span) GetStartTime() time.Time    { return s.startTime }
func (s *span) GetEndTimeNano() int64      { return s.endTime }
func (s *span) IsRequest() bool            { return s.isRequest }

func (s *span) NoPrefill() xopbase.Prefilled {
	return &prefilled{
		span: s,
	}
}

func (b *builder) reset(s *span) {
	b.span = s
	b.B = b.B[:0]
	b.attributesWanted = false
	b.attributesStarted = false
}

func (s *span) builder() *builder {
}

func (s *span) StartPrefill() xopbase.Prefilling {
	return &prefilling{
		builder: s.builder(),
	}
}

func (p *prefilling) PrefillComplete(m string) xopbase.Prefilled {
	return prefilled
}

func (p *prefilled) Line(level xopnum.Level, t time.Time, pc []uintptr) xopbase.Line {
	atomic.StoreInt64(&p.span.endTime, t.UnixNano())
	if level >= xopnum.ErrorLevel {
		if level >= xopnum.AlertLevel {
			_ = atomic.AddInt32(&p.span.request.alertCount, 1) // XXX move to logger and include in flush?
		} else {
			_ = atomic.AddInt32(&p.span.request.errorCount, 1)
		}
	}
	l = &line{
		builder:              p.span.builder(),
		Line: xopproto.Line{
			LogLevel:	int32(level),
			TimeStamp: t.UnixNano(),
		},
		prefillMsgPreEncoded: p.preEncodedMsg,
	}
	return l
}

func (l *line) Template(m string) {
	l.LineKind = xopjson.KindLine
	l.MessageTemplate = m
	l.done()
}

func (l *line) Msg(m string) {
	l.LineKind = xopjson.KindLine
	l.Message = m
	l.done()
}

func (l *line) done() {
	// XXX
}

func (l *line) Model(k string, v xopbase.ModelArg) {
	l.Model = &xopbase.Model{}
	enc, err := json.Marshal(v.Model)
	if err != nil { 
		l.Model.Error = err.Error()
	} else {
		l.Model.Json = enc
	}
	if v.TypeName == "" {
		l.Model.Type = reflect.TypeOf(v.Model).Name()
	} else {
		l.Model.Type = v.TypeName
	}
	l.LineKind = xopjson.KindModel
	l.Message = k 
	l.done()
}

func (l *line) Link(k string, v xoptrace.Trace) {
	l.LineKind = xopjson.KindLink
	l.Message = v.Trace.String() // XXX custom type?
	l.done()
}

/* XXX
func (b *builder) Link(k string, v xoptrace.Trace) {
	b.startAttributes()
	b.AddKey(k)
	b.AddLink(v)
}
*/

func (b *builder) ReclaimMemory() {
	// XXX
}

func (b *builder) AsBytes() []byte            // XXX
func (l *line) GetSpanID() xoptrace.HexBytes8 { return l.span.bundle.Trace.GetSpanID() }
func (l *line) GetLevel() xopnum.Level        { return xopnum.Level(l.LogLevel) }
func (l *line) GetTime() time.Time            { return time.UnixNano(0. l.Timestamp) }

func (l *line) ReclaimMemory() {
}

/*
func (b *builder) AddAny(v interface{}) {
	before := len(b.B)
	err := b.encoder.Encode(v)
	if err != nil {
		b.B = b.B[:before]
		b.span.request.errorFunc(err)
		b.stringKV("encode", err.Error())
	} else {
		// remove \n added by json.Encoder.Encode.  So helpful!
		if b.B[len(b.B)-1] == '\n' {
			b.B = b.B[:len(b.B)-1]
		}
	}
}
*/

func (b *builder) Enum(k *xopat.EnumAttribute, v xopat.Enum) {
	b.Attributes = append(b.Attributes, xopproto.Attribute{
		Key: k.Key(),
		AttributeCommon: &xopproto.AttributeCommon{
			AttributeType: xopproto.AttributeTypeEnum,
			StringValue: v.String(),
			IntValue: v.Int64(),
		},
	})
}

func (b *builder) Time(k string, t time.Time) {
	b.Attributes = append(b.Attributes, xopproto.Attribute{
		Key: k.Key(),
		AttributeCommon: &xopproto.AttributeCommon{
			AttributeType: xopproto.AttributeTypeTime,
			IntValue: t.UnixNano(),
		},
	})
}

func (b *builder) Bool(k string, v bool) {
	b.Attributes = append(b.Attributes, xopproto.Attribute{
		Key: k.Key(),
		AttributeCommon: &xopproto.AttributeCommon{
			AttributeType: xopproto.AttributeTypeBool,
			IntValue: boolToInt64(v),
		},
	})
}

func boolToInt64(b bool) int64 {
	if b { return 1 }
	return 0
}

func (b *builder) Int64(k string, v int64, _ xopbase.DataType) {
	b.Attributes = append(b.Attributes, xopproto.Attribute{
		Key: k.Key(),
		AttributeCommon: &xopproto.AttributeCommon{
			AttributeType: xopproto.AttributeTypeInt64, // Convert to xopproto
			IntValue: v,
		},
	})
}

func (b *builder) Uint64(k string, v uint64, _ xopbase.DataType) {
	b.Attributes = append(b.Attributes, xopproto.Attribute{
		Key: k.Key(),
		AttributeCommon: &xopproto.AttributeCommon{
			AttributeType: xopproto.AttributeTypeUint64, // Convert to xopproto
			UintValue: v,
		},
	})
}

func (b *builder) String(k string, v string, _ xopbase.DataType) {
	b.Attributes = append(b.Attributes, xopproto.Attribute{
		Key: k.Key(),
		AttributeCommon: &xopproto.AttributeCommon{
			AttributeType: xopproto.AttributeTypeString, // Convert to xopproto
			StringValue: v,
		},
	})
}

func (b *builder) Float64(k string, v float64, _ xopbase.DataType) {
	b.Attributes = append(b.Attributes, xopproto.Attribute{
		Key: k.Key(),
		AttributeCommon: &xopproto.AttributeCommon{
			AttributeType: xopproto.AttributeTypeFloat64, // Convert to xopproto
			FloatValue: v,
		},
	})
}

func (b *builder) Duration(k string, v time.Duration) {
	b.Int64(k, v, xopbase.DataTypeDuration)
}

// MACRO BaseAttribute
func (s *span) MetadataZZZ(k *xopat.ZZZAttribute, v zzz) {
	var attribute *xopproto.Attribute
	var existingAttribute bool
	func() {
		s.mu.Lock()
		defer s.mu.Unlock()
		attribute, existingAttribute = s.attributeMap[k.Key()]
		if !existingAttribute {
			attribute = *xopproto.Attribute{
				AttributeDefinitionSequenceNumber: 
				Values: make([]*xopproto.AttributeValue, 1, 1),
			}
			s.Attributes = append(s.Attributes, attribute)
		}
	}()
	if k.Multiple() {
		//CONDITIONAL ONLY:Any
		enc, err := json.Marshal(v)
		if err != nil {
			
		// 
		//END CONDITIONAL
		if k.Distinct() {
			


			
			
		
		"Bool":    "bool",
		"Float64": "float64",
		"Int64":   "int64",
		"String":  "string",
		"Link":    "xoptrace.Trace",
		"Any":     "interface{}",
		"Time":    "time.Time",
		"Enum":    "xopat.Enum",
	} else {
		if k.Locked() && ok { 
			return
		}
	}
}

// end
